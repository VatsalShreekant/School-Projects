/* time_server.c - main */
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <stdio.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
/*------------------------------------------------------------------------
* main - Iterative UDP server for TIME service
*------------------------------------------------------------------------
*/
int
main(int argc, char *argv[])
{
struct sockaddr_in fsin; /* the from address of a client */
char buf[100]; /* "input" buffer; any size > 0 */
char *pts;
int sock; /* server socket */
time_t now; /* current time */
int alen; /* from-address length */
struct sockaddr_in sin; /* an Internet endpoint address */
int s, type; /* socket descriptor and socket type */
int port=3000;
struct pdu{ 
// used for holding information about content and peer
char type;
char data[100];
char peer_name[10];
char content_name[10];
char IP[20];
      int port;
};
struct pdu2{ 
// used for data transfer
      char type;
      char data[100];
};
switch(argc){
case 1:
break;
case 2:
      port = atoi(argv[1]);
break;
default:
      fprintf(stderr, "Usage: %s [port]\n", argv[0]);
exit(1);
}
memset(&sin, 0, sizeof(sin));
sin.sin_family = AF_INET;
sin.sin_addr.s_addr = INADDR_ANY;
sin.sin_port = htons(port);
/* Allocate a socket */
s = socket(AF_INET, SOCK_DGRAM, 0);
if (s < 0)
      fprintf(stderr, "can't create socket\n");
/* Bind the socket */
if (bind(s, (struct sockaddr *)&sin, sizeof(sin)) < 0)
      fprintf(stderr, "can't bind to %d port\n",port);
listen(s, 5);
      alen = sizeof(fsin);
// my code start here
struct pdu spdu; // creates structure
struct pdu spdu2; // creates structure
struct pdu spdu3;
struct pdu spdu4;
struct pdu content1;
struct pdu content2;
struct pdu content3;
struct pdu2 spdu11; // creates structure
struct pdu2 spdu22;
FILE *fr; // created file pointer
int ii, jj;
char registeredContent[100];
int result, result2, result3, result11, result22, result33; // used to hold results
char cmp1[10], cmp11[10], cmp2[10], cmp22[10], cmp3[10], cmp33[10],
cmp4[10], cmp44[10]; // used to hold string for comparison
int inuse1 = 0; // used to see if a content is valid
int inuse2 = 0; // used to see if a content is valid
int inuse3 = 0; // used to see if a content is valid
while (1) { // only exit when client end connection
if (recvfrom(s, &spdu, 200, 0,
(struct sockaddr *)&fsin, &alen) < 0) // reads PDU from
client // problem is recvfrom
fprintf(stderr, "recvfrom error\n"); // if there is a problem display
to server
printf("IP: %s \n", spdu.IP); // display the IP of the received PDU // for
debug purposes only
printf("Port: %d \n", spdu.port); // display the port value of the received
PDU // for debug purposes only

//content registration start here
if( spdu.type == 'R'){
strncpy( cmp1,spdu.content_name,10); // copy the first 10 bits
strncpy( cmp11,spdu.peer_name,10); // copy the first 10 bits
strncpy( cmp2,content1.content_name,10); // copy the first 10 bits
strncpy( cmp22,content1.peer_name,10); // copy the first 10 bits
result = strcmp(cmp1,cmp2); // compare strings // If Result Is Zero It Means That
The Strings Match
result11 = strcmp(cmp11,cmp22); // compare strings // if result is zero it means
that the strings match
strncpy( cmp3,content2.content_name,10);
strncpy( cmp33,content2.peer_name,10);
result2 = strcmp(cmp1,cmp3);
result22 = strcmp(cmp11,cmp33);
strncpy( cmp4,content3.content_name,10);
strncpy( cmp44,content3.peer_name,10);
result3 = strcmp(cmp1,cmp4);
result33 = strcmp(cmp11,cmp44);
if ( (result == 0 && result11 == 0) || (result2 == 0 && result22 == 0) ||
(result3 == 0 && result33 == 0) ){ // if strings are the same it means that the
content with that specific peer name is already in use
spdu.type ='E';
strcpy(spdu.data,"NAME ALREADY IN USE");
(void) sendto(s, &spdu, strlen(spdu.data)+1, 0,
(struct sockaddr *)&fsin, sizeof(fsin)); // send PDU to client
}
if(inuse1 == 0){ // if the content1 PDU is not in use, use it to register the new
content
strcpy(content1.content_name,spdu.content_name); 
strcpy(content1.peer_name,spdu.peer_name); 
strcpy(content1.IP,spdu.IP); 
content1.port = spdu.port; 
printf("contentnameregistered: %s \n", content1.content_name); // display the
content to the index server
printf("peerregistered: %s \n", content1.peer_name); // display the content to the
index server
printf("portregistered: %d \n", content1.port); // display the content to the index
server
inuse1 = 1;
spdu.type ='A';
strcpy(spdu.data,"NAME REGISTRED SUCESIFULLY");
(void) sendto(s, &spdu, strlen(spdu.data)+1, 0,
(struct sockaddr *)&fsin, sizeof(fsin)); // send ACK PDU to client
}
else if( inuse2 == 0 ){
strcpy(content2.content_name,spdu.content_name); 
strcpy(content2.peer_name,spdu.peer_name); 
strcpy(content2.IP,spdu.IP); 
content2.port = spdu.port; 
inuse2 = 1;
spdu.type ='A';
strcpy(spdu.data,"NAME REGISTRED SUCESIFULLY");
(void) sendto(s, &spdu, strlen(spdu.data)+1, 0,
(struct sockaddr *)&fsin, sizeof(fsin)); // send ACK PDU to client
}
else if( inuse3 == 0 ){
strcpy(content3.content_name,spdu.content_name); // ADD NEW CONTENT
strcpy(content3.peer_name,spdu.peer_name); // ADD NEW CONTENT
strcpy(content3.IP,spdu.IP); 
content3.port = spdu.port; 
inuse3 = 1;
spdu.type ='A';
strcpy(spdu.data,"NAME REGISTRED SUCESIFULLY");
(void) sendto(s, &spdu, strlen(spdu.data)+1, 0,
(struct sockaddr *)&fsin, sizeof(fsin)); // send ACK PDU to client
}
}
//content registration ends here

// content list start here
if( spdu.type == 'O'){
content1.type ='O';
(void) sendto(s, &content1, 200, 0,
(struct sockaddr *)&fsin, sizeof(fsin));
content2.type ='O';
(void) sendto(s, &content2, 200, 0,
(struct sockaddr *)&fsin, sizeof(fsin));
content3.type ='O';
(void) sendto(s, &content3, 200, 0,
(struct sockaddr *)&fsin, sizeof(fsin));
//send 3 contents to client
}
// content list ends here

// de-register start here
if( spdu.type == 'T'){
strncpy( cmp1,spdu.content_name,10); // copy the first 10 bits
strncpy( cmp11,spdu.peer_name,10); // copy the first 10 bits
strncpy( cmp2,content1.content_name,10);
strncpy( cmp22,content1.peer_name,10);
result = strcmp(cmp1,cmp2);
result11 = strcmp(cmp11,cmp22);
strncpy( cmp3,content2.content_name,10);
strncpy( cmp33,content2.peer_name,10);
result2 = strcmp(cmp1,cmp3);
result22 = strcmp(cmp11,cmp33);
strncpy( cmp4,content3.content_name,10);
strncpy( cmp44,content3.peer_name,10);
result3 = strcmp(cmp1,cmp4);
result33 = strcmp(cmp11,cmp44);
if ( (result != 0 || result11 != 0 ) && (result2 != 0 || result22 != 0) && (result3 !=
0 || result33 != 0) ){ // If The Content Name Is Not There
spdu.type ='E';
strcpy(spdu.data,"Name Is Incorrect, Exiting De-Register");
//strlen(spdu.data)+1
(void) sendto(s, &spdu, 200, 0,
(struct sockaddr *)&fsin, sizeof(fsin)); // send PDU to client
}
if(result == 0 && result11 == 0){
strcpy(content1.content_name,"NULL"); // de-register CONTENT
strcpy(content1.peer_name,"NULL"); // de-register CONTENT
strcpy(content1.IP,"NULL"); // de-register CONTENT
content1.port = 0; // de-register CONTENT
inuse1 = 0;
spdu.type ='A';
strcpy(spdu.data,"NAME DE-REGISTRED SUCESIFULLY");
(void) sendto(s, &spdu, strlen(spdu.data)+1, 0,
(struct sockaddr *)&fsin, sizeof(fsin)); // send ACK PDU to client
}
else if( result2 == 0 && result22 == 0){
strcpy(content2.content_name,"NULL"); // de-register CONTENT
strcpy(content2.peer_name,"NULL"); // de-register CONTENT
strcpy(content2.IP,"NULL"); // de-register CONTENT
content2.port = 0; // de-register CONTENT
inuse2 = 0;
spdu.type ='A';
strcpy(spdu.data,"NAME DE-REGISTRED SUCESIFULLY");
(void) sendto(s, &spdu, strlen(spdu.data)+1, 0,
(struct sockaddr *)&fsin, sizeof(fsin)); // send ACK PDU to client
}
else if( result3 == 0 && result33 == 0 ){
strcpy(content3.content_name,"NULL"); // de-register CONTENT
strcpy(content3.peer_name,"NULL"); // de-register CONTENT
strcpy(content3.IP,"NULL"); // de-register CONTENT
content3.port = 0; // de-register CONTENT
inuse3 = 0;
spdu.type ='A';
strcpy(spdu.data,"name de-registered sucessfully");
(void) sendto(s, &spdu, strlen(spdu.data)+1, 0,
(struct sockaddr *)&fsin, sizeof(fsin)); // send ACK PDU to client
}
}
// de-register ends here

// search for content and the associated content server starts here
if( spdu.type == 'S'){
strncpy( cmp1,spdu.content_name,10); // copy the first 10 bits
strncpy( cmp11,spdu.peer_name,10); // copy the first 10 bits
strncpy( cmp2,content1.content_name,10);
result = strcmp(cmp1,cmp2);
strncpy( cmp3,content2.content_name,10);
result2 = strcmp(cmp1,cmp3);
strncpy( cmp4,content3.content_name,10);
result3 = strcmp(cmp1,cmp4);
if ( (result != 0) && (result2 != 0) && (result3 != 0) ){ // if the content name is
not there
spdu.type ='E';
strcpy(spdu.data,"NAME IS INCORRECT, EXITING CONTENT SEARCH");
(void) sendto(s, &spdu, strlen(spdu.data)+1, 0,
(struct sockaddr *)&fsin, sizeof(fsin)); // send PDU to client
}
if( result3 == 0 ){ // newest content is selected over old content
content3.type ='S';
printf("Content3 that is going to be sent \n");
printf(" IP: %s", content3.IP);
printf(" Port: %d", content3.port);
(void) sendto(s, &content3, 200, 0,
(struct sockaddr *)&fsin, sizeof(fsin));
}
else if( result2 == 0 ){
content2.type ='S';
printf("Content2 that is going to be sent \n");
printf(" IP: %s", content2.IP);
printf(" Port: %d", content2.port);
(void) sendto(s, &content2, 200, 0,
(struct sockaddr *)&fsin, sizeof(fsin));
}
else if(result == 0){
content1.type ='S';
//strlen(content1.data)+1
printf("Content1 that is going to be sent \n");
printf(" IP: \n%s", content1.IP);
printf(" \nPort: \n\n%d", content1.port);
printf("\n");
(void) sendto(s, &content1, 200, 0,
(struct sockaddr *)&fsin, sizeof(fsin));
}
}
// search for content and the associated content server ends here
//index server ends
} //while (1) ends here
}
/*------------------------------------------------------------------------
* End of Index Server
*------------------------------------------------------------------------
*/
