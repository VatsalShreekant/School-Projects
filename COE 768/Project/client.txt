/* A P2P client
It provides the following functions:
- Register the content file to the index server (R)
- Contact the index server to search for a content file (D) 
	- Contact the peer to download the file
	- Register the content file to the index server
- De-register a content file (T)
- List the local registered content files (L)
- List the on-line registered content files (O)
*/

#include <stdio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <strings.h>
#include <string.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/select.h>
#include <errno.h>


#define QUIT "quit"
#define SERVER_PORT 10000	/* well-known port */
#define BUFLEN	100		/* buffer length */
#define NAMESIZ 10
#define MAXCON	200
#define ERRMSG1	"Cannot find the media\n"

typedef struct 
{
char 	type;
char	data[BUFLEN];
} PDU;	
PDU	rpdu;

struct {
	int	val;
	char 	name[NAMESIZ];
} table[MAXCON];  //Keep Track of the registered content

char usr[NAMESIZ];

int s_sock,peer_port;
int fd, nfds;
fd_set rfds, afds;

void 	registration(int, char *); 
int 	search_content(int, char *, PDU *);
int 	client_download(char *, PDU *);
void 	server_download();
void 	deregistration(int, char *);
void	online_list(int);
void	local_list();
void	quit(int);
void	handler();

int main(int argc, char **argv)
{
	int	s_port = SERVER_PORT;
	int 	n;
	int	alen = sizeof(struct sockaddr_in);
	struct	hostent		*hp;
	struct	sockaddr_in server;
	char	c, name[NAMESIZ];
	char	*host = "localhost";
	struct	sigaction sa;

	switch(argc){
		case 1:
			break;
		case 2:
	  		host = argv[1];
	  		break;
		case 3:
  	  		host = argv[1];
	  		s_port = atoi(argv[2]);
			break;
		default:
	  		printf("Usage: %s host [port]\n", argv[0]);
	  		exit(1);
	}

  /* UDP Connection with the index server		*/ 
	memset(&server, 0, alen);
	server.sin_family = AF_INET;
	server.sin_port = htons(s_port);
	if ( hp = gethostbyname(host) )
		memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
	else if ( (server.sin_addr.s_addr = inet_addr(host)) == INADDR_NONE ){
        	printf("Can't get host entry \n");
    		exit(1);
	}
	s_sock = socket(PF_INET, SOCK_DGRAM, 0); // Allocate a socket for the index server
	if (s_sock < 0){
    		printf("Can't create socket \n");
    		exit(1);
	} 
	if (connect(s_sock, (struct sockaddr *)&server, sizeof(server)) < 0){
		printf("Can't connect \n");
		exit(1);
	}

/* 	Enter User Name		*/
	printf("Choose a user name\n");
	scanf("%s",usr);

/* Initialization of SELECT`structure and table structure	*/
	FD_ZERO(&afds);
	FD_SET(s_sock, &afds);       /* Listening on the index server socket  */
	FD_SET(0, &afds);       /* Listening on the read descriptor   */
	nfds = 1;
	for(n=0; n<MAXCON; n++)
		table[n].val = -1;

/*	Setup signal handler		*/
	sa.sa_handler = handler;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	sigaction(SIGINT, &sa, NULL);
                                                                                
/* Main Loop	*/
	while(1){
	  printf("Command:\n");

	  memcpy(&rfds, &afds, sizeof(rfds));
    	  if (select(nfds, &rfds, NULL, NULL, NULL) == -1){
       	    printf("select error: %s\n",strerror(errno));
       	    exit(1);
	  }

    	  if (FD_ISSET(0, &rfds)) {  /* Command from the user  */
	    c = getchar();

/*	Command options	*/
	    if(c=='?'){
		printf("R-Content Registration; T-Content Deregistration; L-List Local Content\n");
       	 	printf("D-Download Content; O-List all the On-line Content; Q-Quit\n\n");
		continue;
	    }

/*	Content Regisration	*/
    	    if(c=='R'){
	      printf("Enter the name of the content\n");
	      scanf("%s",name);
	      registration(s_sock, name); // Register content to the index server
	      continue;
  	    }

/*	List Content		*/
	    if(c == 'L'){
		local_list();
	      	continue;
	    }

/*	List on-line Content	*/
	    if(c == 'O'){
		online_list(s_sock);
	      	continue;
	    }

/*	Download Content	*/
  	    if(c=='D'){
	      	printf("Enter the name of the Content\n");
	      	scanf("%s",name);
		if(search_content(s_sock,name, &rpdu) == 0)
		if(client_download(name, &rpdu) == 0) 				   			registration(s_sock,name);
	   	continue;
	    }

/*	Content Deregistration	*/
	    if(c == 'T'){
		printf("Enter the name of the Content\n");
		scanf("%s",name);
		deregistration(s_sock,name);
	    	continue;
	    }

/*	Quit	*/
	    if(c == 'Q'){
		quit(s_sock);
	    	exit(1);
  	    }

	    
  	  }


/* Content transfer: Server to client		*/
	  server_download(s_sock);
	}
return 0;
}

void	quit(int s_sock)
{
	int	n;
        for(n=3; n<nfds; n++){
      		if(table[n].val == 1)
                deregistration(s_sock,table[n].name);
        }
	return;
}

void	local_list()
{
	int n;

	printf("\nLocal Content List\n");
	for(n=3; n<nfds; n++){
                if(table[n].val == 1)
                  	printf("%s\n", table[n].name);
        }
        printf("\n");
	return;
}

void	online_list(int s_sock)
{
	PDU	tpdu;
 	tpdu.type = 'O';
        write(s_sock, &tpdu, sizeof(tpdu));
        read(s_sock, &rpdu, sizeof(tpdu));
        printf("\nOn-line Content List:\n%s\n", rpdu.data);
        printf("\n");
	return;
}



void	server_download()
{
	int	n, i, new_sd, alen;
	struct sockaddr_in	client;
	PDU	tpdu;

	for(i=3; i<nfds; ++i){
		if (FD_ISSET(i, &rfds)) {
	    	  new_sd = accept(i, (struct sockaddr *)&client, &alen);
	    	  n=read(new_sd, &rpdu, sizeof(rpdu));
	    	  if(rpdu.type=='D'){
			fd = open(table[i].name,O_RDONLY);
			if(fd >= 0){
		  	  tpdu.type = 'C';
			  n = read(fd, tpdu.data, BUFLEN);
			  write(new_sd, &tpdu, n+1);
		  	  while((n = read(fd, tpdu.data, BUFLEN))>0)
	 	    		write(new_sd, tpdu.data, n);
		  	  printf("complete transmission\n");
			}
			else{
			  tpdu.type = 'E';
			  write(new_sd, &tpdu, sizeof(tpdu));
			}
	  	  	close(fd);
	    	  	close(new_sd);
		  }
  	  	}
	}

	return;
}


int search_content(int s_sock, char *name, PDU *rpdu)
{
	int	n;
	PDU	tpdu;

	tpdu.type = 'S';
        memcpy(tpdu.data, name, NAMESIZ);
        if((n=write(s_sock, &tpdu, BUFLEN+1)) < 0){
                printf("Search_content: write error\n");
                return -1;
        }
        if((n = read(s_sock, rpdu, BUFLEN+1))<0){
                printf("Search_Content: read error\n");
                return -1;
        }
        if(rpdu->type == 'E'){
                printf("Search_Content: Cannot find content %s\n\n",name);
                return -1;
        }
 	if(rpdu->type == 'S'){
		printf("Search: Find content\n");
		return 0;
	}
	else{
		printf("Search_Content: Protocol Error	\n");
		return -1;
	}
}

int client_download(char *name, PDU *pdu)
{
	struct 	sockaddr_in p_addr;
	int	p_sock, n, fd;
	PDU	tpdu, rpdu;
	
	memcpy(&rpdu, pdu, sizeof(PDU));
        memcpy(&p_addr, rpdu.data, sizeof(p_addr));
        printf("Download: Peer IP Address %d\n", p_addr.sin_addr.s_addr);
        printf("Download: Peer Port Number %d\n", ntohs(p_addr.sin_port));
        if ((p_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        	printf("Download: Can't creat a socket\n");
        	return -1;
        }
        if (connect(p_sock, (struct sockaddr *)&p_addr, sizeof(p_addr)) == -1){
        	printf("Download: Can't connect to the remote peer \n");
        	return -1;
        }

        tpdu.type = 'D';
        write(p_sock, &tpdu, 1);
        fd = open(name,  O_CREAT|O_RDWR|O_TRUNC,  S_IRWXU);
	if(fd < 0){
		printf("Download: Can't open file\n");
		return -1;
	}
                                                                                                                    
        n=read(p_sock, &rpdu, sizeof(PDU));
      	if(rpdu.type == 'C'){
        	write(fd, rpdu.data, n-1);
        	while((n=read(p_sock, rpdu.data, BUFLEN))>0){
		  write(fd, rpdu.data, n);
		}
	}
	else{
		if(rpdu.type == 'E') 
		  printf("Download: Content is not available at the remote peer\n");
		else
		  printf("Download: Protocol Error\n");
		close(fd);
		close(p_sock);
		return -1;
	}
        close(fd);
        close(p_sock);
	return 0;
}

void deregistration(int s_sock,char *name)
{
 	int	n, find = -1;
	PDU	tpdu, rpdu;

	for(n=3; n<nfds; n++)
        	if(strcmp(table[n].name, name)==0){
			if(table[n].val == 1)
                    		find = n;
                }

        if(find == -1){
		printf("De-Registration: Content %s is not registered\n", name);
		return;
	}
        else{
       		if(table[find].val == -1){
                	printf("De-Registration: Content %s is not registered\n",name);
			return;
		}
                FD_CLR(find, &afds);
                if(nfds == find+1) nfds = find;
		table[find].val = -1;
                close(find);
        }

	tpdu.type = 'T';
	strcpy(tpdu.data, name);
	strcpy(&tpdu.data[NAMESIZ], usr);
	write(s_sock, &tpdu, sizeof(tpdu));
	read(s_sock, &rpdu, sizeof(rpdu));
	if(rpdu.type == 'T'){
		printf("De-Registration: Content %s is successfully de-registered\n", name);
		return;
	}
	else{ 
		printf("De-Registration: content %s is not registered\n",name); 
		return;
	}
}


void registration(int s_sock,char *name)
{
	struct sockaddr_in reg_addr, addr;
	int p_sock, alen, n;
        int p_port = 0;
	PDU	tpdu, rpdu;

	alen = sizeof(struct sockaddr_in);
        /* Create a stream socket for content download    */
        if ((p_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                printf("Registration: Can't creat a socket\n");
                return;
        }

        /* Create a socket for Content download        */
        memset(&reg_addr, 0, sizeof(struct sockaddr_in));
        reg_addr.sin_family = AF_INET;
        reg_addr.sin_port = htons(0);
        reg_addr.sin_addr.s_addr = htonl(INADDR_ANY);
        if (bind(p_sock, (struct sockaddr *)&reg_addr, sizeof(reg_addr)) == -1){
                printf("Registration: Can't bind name to socket\n");
                return;
        }
	listen(p_sock,5);
	getsockname(p_sock, (struct sockaddr *) &reg_addr, &alen);
        tpdu.type = 'R';
        memcpy(&tpdu.data[NAMESIZ], name, NAMESIZ);
        memcpy(&tpdu.data[2*NAMESIZ],&reg_addr.sin_port,sizeof(reg_addr.sin_port));
	while(1){
        	memcpy(tpdu.data, usr, NAMESIZ);
        	if( (n=write(s_sock, &tpdu, sizeof(tpdu))) <=0 ){
			printf("Registration: write Error\n");
			return;
		}
        	if ((n=read(s_sock, &rpdu, sizeof(rpdu))) <0) {
			printf("Registration: read error\n");
			return;
		}
    		if(rpdu.type == 'A'){
 			FD_SET(p_sock, &afds);
              		table[p_sock].val = 1;
              		strcpy(table[p_sock].name,name);
              		if(nfds <= p_sock)
               		 	nfds = p_sock+1;
			printf("Registration: name %s\n",name);
			printf("Registration: Port: %d\n\n", ntohs(reg_addr.sin_port));
			return;
		}
        	if(rpdu.type == 'E'){
               		printf("Name conflict! Please choose other name for the content\n");
                	scanf("%s",usr);
			if(strcmp(name, QUIT)== 0) exit(1);
                }

        }
        printf("Registration: protocol Error\n\n");
}

void	handler()
{
	quit(s_sock);
}